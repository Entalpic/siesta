# Copyright 2025 Entalpic
import operator
from collections.abc import Generator
from functools import reduce
from pathlib import Path
from typing import Any, Callable

from gitignore_parser import parse_gitignore

from siesta.utils.common import get_project_name

# prefix components:
SPACE = "    "
BRANCH = "│   "
# pointers:
TEE = "├── "
LAST = "└── "
TREE_LABELS = {
    ".git/": "Contains the git data repository for your project. Do NOT touch this folder.",
    ".github/": "Contains the GitHub Actions workflows for your project.",
    ".gitignore": "Specifies files and directories that should be ignored by git.",
    ".pre-commit-config.yaml": "Contains the 'hooks', i.e. routines, that are executed before each commit.",
    ".readthedocs.yaml": "Config file to deploy your docs to ReadTheDocs (ask Victor).",
    "docs/": "Contains the documentation for your project.",
    "docs/source/": "Contains the documentation's source code that will be rendered by Sphinx.",
    "docs/source/conf.py": "Configures your Sphinx-based documentation.",
    "pyproject.toml": "Describes and configures your Python project, including its metadata and dependencies.",
    "README.md": "The Markdown file that you should always keep up to date with description & installation steps.",
    "src/": "Contains the source code for your project.",
    "tests/": "Contains the test files for your project.",
    "uv.lock": "Do not edit this file manually, it is managed by uv.",
}


def func_or(*funcs) -> Callable[[Any], bool]:
    """Return a function that ORs all given predicates."""
    return lambda x: reduce(operator.or_, (f(x) for f in funcs))


def get_filler_from_line(line: str, target_line_length: int) -> str:
    """Get the filler from the line so that a new line is consistent with the tree structure.

    Parameters
    ----------
    line : str
        The line to get the filler from.
    target_line_length : int
        The target line length.

    Returns
    -------
    str
        The filler.
    """
    line_is_tee_or_branch = [k for k, c in enumerate(line) if c in {TEE[0], BRANCH[0]}]
    line_is_last = [k for k, c in enumerate(line) if c == LAST[0]]
    filler = " " * (target_line_length + 4)
    for i in line_is_tee_or_branch:
        filler = filler[:i] + "│" + filler[i + 1 :]
    for i in line_is_last:
        i = i + len(SPACE)
        filler = filler[:i] + "│" + filler[i + 1 :]
    return filler


def tree(
    dir_path: Path,
    should_skip_function: Callable[[Path], bool] | None = None,
    prefix: str = "",
) -> Generator[dict[str, Any], None, None]:
    """A recursive generator, given a directory Path object
    will yield a visual tree structure line by line
    with each line prefixed by the same characters

    Parameters
    ----------
    dir_path : Path
        The directory to make a tree of.
    should_skip_function : Callable[[Path], bool], optional
        A function that returns True if the path should be skipped.
    prefix : str, optional
        The prefix to add to each line.

    Yields
    ------
    dict
        A dictionary with the following keys:
        - ``"line"``: The tree line.
        - ``"path"``: The path of the file or directory.
    """
    local_should_skip_function = func_or(
        should_skip_function or (lambda x: False),
        lambda x: dir_path.name == ".git",
    )
    if (dir_path / ".gitignore").exists():
        matches_local_ignore = parse_gitignore(dir_path / ".gitignore")
        local_should_skip_function = func_or(
            local_should_skip_function,
            matches_local_ignore,
        )

    contents = [p for p in dir_path.iterdir() if not local_should_skip_function(p)]
    contents = sorted(
        (p for p in contents if p.name.startswith(".")), key=lambda x: x.name
    ) + sorted(
        (p for p in contents if not p.name.startswith(".")), key=lambda x: x.name
    )

    # contents each get pointers that are ├── with a final └── :
    pointers = [TEE] * (len(contents) - 1) + [LAST]
    for pointer, path in zip(pointers, contents):
        yield {
            "line": prefix + pointer + path.name + ("/" if path.is_dir() else ""),
            "path": path,
        }
        if path.is_dir():  # extend the prefix and recurse:
            extension = BRANCH if pointer == TEE else SPACE
            # i.e. space because last, └── , above so no more |
            yield from tree(
                path,
                prefix=prefix + extension,
                should_skip_function=local_should_skip_function,
            )


def wrap_consequent_chars(
    line: str, char: str = "·", style: str = "grey3", split_new_lines: bool = False
) -> str:
    """Wrap a repeating character in a string with a ``rich`` style.

    `Available Colors <https://rich.readthedocs.io/en/stable/appendix/colors.html>`_.

    Example
    -------
    >>> wrap_consequent_chars("Hello ·········· World", "·", "bold grey3")
    "Hello [bold grey3]··········[/bold grey3] World"

    Parameters
    ----------
    line : str
        The line to wrap the character in.
    char : str
        The character to wrap.
    style : str
        The style of the character.
    split_new_lines : bool
        Whether to split the line into multiple lines.

    Returns
    -------
    str
        The wrapped line.
    """
    if split_new_lines and "\n" in line:
        return "\n".join(
            wrap_consequent_chars(nl, char, style, split_new_lines=False)
            for nl in line.split("\n")
        )
    start = line.find(char)
    if start == -1:
        return line
    end = line.rfind(char) + 1
    return line[:start] + f"[{style}]" + line[start:end] + f"[/{style}]" + line[end:]


def label_tree(
    tree_dicts: list[dict[str, Any]], reference_path: Path, max_line_length: int
) -> list[str]:
    """Label the tree lines.

    Parameters
    ----------
    tree_dicts : list[dict[str, Any]]
        The tree dicts to label.
    reference_path : Path
        The path to the reference directory.
    max_line_length : int
        The maximum line length.

    Returns
    -------
    list[str]
        The labeled tree lines.
    """

    TREE_LABELS[f"src/{get_project_name(interactive=False, snake_case=True)}/"] = (
        "Your (first?) package should live in here."
    )

    longest_line = max(
        len(td["line"]) for td in tree_dicts if td["line"].split(" ")[-1] in TREE_LABELS
    )
    new_lines = []
    for td in tree_dicts:
        key = str(td["path"].relative_to(reference_path).as_posix()) + (
            "/" if td["path"].is_dir() else ""
        )
        candidate = td["line"]
        if key in TREE_LABELS:
            dots = "·" * (longest_line - len(candidate))
            candidate = f"{candidate} {dots} [grey50]# {TREE_LABELS[key]}[/grey50]"

        # Line is too long, break it into multiple lines if it's a labeled line
        if len(candidate) > max_line_length and key in TREE_LABELS:
            parts = candidate.split(" ")
            new_line = ""
            counter = 0
            while parts:
                p = parts.pop(0)
                # Current new line is too long, break it
                if counter + len(p) + 1 > max_line_length:
                    # Add filling characters to make the new line consistent with the tree structure
                    filler = get_filler_from_line(td["line"], longest_line)
                    # Make sure rich style markup is consistent per line
                    if "[grey50]" in new_line and "[/grey50]" not in new_line:
                        new_line += "[/grey50]\n" + filler + "[grey50]"
                    else:
                        new_line += "\n" + filler
                    # Reset counter because we've added a new line
                    counter = 0
                new_line += " " + p if counter else p
                counter += len(p) + 1
            candidate = new_line
        new_lines.extend(candidate.split("\n"))

    return [wrap_consequent_chars(nl) for nl in new_lines]


def make_labeled_tree(
    dir_path: Path | str,
    should_skip_function: Callable[[Path], bool] | None = None,
    max_line_length: int = 80,
) -> str:
    """Make a labeled tree of the directory.

    Something like:

    .. code-block::

        .
        ├── docs ··········· Contains the documentation for your project.
        │   ├── build
        │   ├── source
        │   └── _static
        └── src ············ Contains the source code for your project.
        ...

    Parameters
    ----------
    dir_path : Path | str
        The path to the directory to make a tree of.
    should_skip_function : Callable[[Path], bool], optional
        A function that returns True if the path should be skipped.
    max_line_length: int
        Maximum allowed line length (longer lines are broken to new lines)

    Returns
    -------
    str
        The labeled tree.
    """
    # FIXME
    # The following scenario requires a look-ahead and isn't supported yet:
    # └── boilerplate
    #     ├── Makefile
    #     ├── source ·································· Contains the documentation's
    #     │          source code that will be rendered by Sphinx. <<-- here the index line should go up
    #     │   ├── index.rst
    #     ...
    dir_path = Path(dir_path)
    tree_dicts = list(tree(dir_path, should_skip_function=should_skip_function))
    tree_lines = label_tree(tree_dicts, dir_path, max_line_length)
    return "\n".join(tree_lines)
